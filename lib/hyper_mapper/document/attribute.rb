require 'securerandom'

module HyperMapper
  module Document
    module ClassMethods
      
      def key_name
        @key_name ? @key_name.to_sym : nil
      end
      
      def foreign_key
        "#{self.model_name.underscore}_#{key_name}"
      end
      
      def embedded_collection_name
        model_name.underscore.pluralize
      end

      def key_name=(v)
        @key_name = v
        validates_presence_of v
      end
      
      def attr_accessible(*attrs)
        @attr_accessible = attrs
      end
      
      def verify_attr_accessible!(attrs) 
        attrs.each do |key, value|
          unless (@attr_accessible || {}).include? key.to_sym
            raise Exceptions::MassAssignmentException.new("#{key} cannot be modified via mass assignment")
          end
        end
      end
      
      def attribute_meta_data
        @attributes_meta_data ||= {}
      end

      def attributes
        @attributes ||= {}
      end
      
      def create_attribute(name, params)
        unless params[:embedded] || params[:embedded_in]
          attribute_meta_data[name] = params
          attributes[name] = name
        end
      end
      
      def key(name, params={})
        attribute name, params.merge(key: true)
      end

      def autogenerate_id(name=:id, params={})
        attribute name, params.merge(key: true, autogenerate: true)
      end
      
      def autogenerate_key?
        @autogenerate_key || false
      end

      def attribute(name, params={})
        
        create_attribute(name, params) 
        
        if (params.has_key? :key) && params[:key]
          self.key_name = name
          if params[:autogenerate]
            @autogenerate = true
            before_save :set_autogenerated_key
          end
        end

        define_method "#{name}=" do |val|
          if params[:type] == :int && (val.respond_to? :to_i)
            val = val.to_i
          elsif params[:type] == :float && (val.respond_to? :to_f)
            val = val.to_f
          elsif params[:type] == :datetime && (val.respond_to? :to_i)
            val = val.to_i
          end
          set_attribute_value name, val
        end

        define_method "#{name}" do
          get_attribute_value name, params[:type]
        end
      end
    end

    class AttributeValue
      attr_accessor :name, :value, :dirty

      def initialize(name, value, dirty=true)
        @name = name
        @value = value
        @dirty = dirty
      end
      
      def value=(v)
        @value = v
        @dirty = true
      end

      def dirty?
        @dirty
      end
    end
    
    def random_string
      "#{Time.now.to_i.to_s}-#{SecureRandom.uuid}"
    end
    
    def set_autogenerated_key
      kattr = attribute_values_map[self.class.key_name]
      return if kattr && kattr.value
      
      unless kattr
        kattr = AttributeValue.new self.class.key_name, nil 
      end
      
      kattr.value = random_string
      attribute_values_map[self.class.key_name] = kattr
    end

    def key_value
      kattr = attribute_values_map[self.class.key_name]
      kattr ? kattr.value : nil
    end 

    def to_key
      [key_value]
    end
    
    def to_param
      key_value
    end

    def model_name
      self.class.name
    end    

    def attribute_values_map
      @attribute_values ||= {}
    end
    
    def attributes
      res = {}
      self.class.attributes.each do |k, v|
        v = attribute_values_map[k]
        res[k] = v ? v.name.to_s : ""
      end
      res
    end

    def clean_attributes!
      attribute_values_map.each do |k, v|
        v.dirty = false
      end
    end
    
    def attributes_for_save
      attrs = attribute_values_map.inject({}) do |acc, (key, field)|
        if field && field.dirty
          acc[key] = field.value
        end
        acc
      end

      self.class.embedded_classes.each do |children|
        if self.send(children).length > 0
          attrs[children] = self.send(children).to_json
        else
          attrs.delete children
        end
      end
      
      attrs.delete self.class.key_name

      attrs
    end

    def set_attribute_value(name, val)
      if attribute_values_map.has_key? name
        attribute_values_map[name].value = val
      else
        attribute_values_map[name] = AttributeValue.new(name, val)
      end
    end

    def get_attribute_value(name, type=:string)
      attr_object = attribute_values_map[name]
      return nil unless attr_object
      if type == :datetime
        Time.at attr_object.value
      else
        attr_object.value
      end
    end
  end
end
